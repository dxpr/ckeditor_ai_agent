!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.CKEditor5=n():(e.CKEditor5=e.CKEditor5||{},e.CKEditor5.aiassist=n())}(self,(()=>(()=>{var __webpack_modules__={"./js/ckeditor5_plugins/aiassist/src/aiassist.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AiAssist)\n/* harmony export */ });\n/* harmony import */ var ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ckeditor5/src/core */ \"ckeditor5/src/core.js\");\n/* harmony import */ var _aiassistui_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aiassistui.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistui.js\");\n/* harmony import */ var _aiassistediting_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aiassistediting.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistediting.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./const.js */ \"./js/ckeditor5_plugins/aiassist/src/const.js\");\n\n\n\n\n\nclass AiAssist extends ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor(editor) {\n    super(editor);\n    this.DEFAULT_GPT_MODEL = 'gpt-4o';\n    this.DEFAULT_AI_END_POINT = 'https://kavya.dxpr.com/v1/chat/completions';\n    const config = editor.config.get('aiAssist') || {};\n    // Set default values and merge with provided config\n    const defaultConfig = {\n      model: this.DEFAULT_GPT_MODEL,\n      apiKey: 'YOUR_API_KEY',\n      endpointUrl: this.DEFAULT_AI_END_POINT,\n      temperature: undefined,\n      timeOutDuration: 45000,\n      maxTokens: _const_js__WEBPACK_IMPORTED_MODULE_3__.TOKEN_LIMITS[this.DEFAULT_GPT_MODEL].max,\n      retryAttempts: 1,\n      contextSize: _const_js__WEBPACK_IMPORTED_MODULE_3__.TOKEN_LIMITS[this.DEFAULT_GPT_MODEL].context * 0.75,\n      stopSequences: [],\n      promptSettings: {\n        outputFormat: [],\n        contextData: [],\n        filters: [] // Default filters\n      },\n      debugMode: false,\n      streamContent: true // Default streaming mode\n    };\n    const updatedConfig = { ...defaultConfig, ...config };\n    // Set the merged config back to the editor\n    editor.config.set('aiAssist', updatedConfig);\n    // Validate configuration\n    this.validateConfiguration(updatedConfig);\n  }\n  static get requires() {\n    return [_aiassistui_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _aiassistediting_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]];\n  }\n  static get pluginName() {\n    return 'AiAssist';\n  }\n  validateConfiguration(config) {\n    if (!config.apiKey) {\n      throw new Error('AiAssist: apiKey is required.');\n    }\n    if (config.temperature && (config.temperature < 0 || config.temperature > 2)) {\n      throw new Error('AiAssist: Temperature must be a number between 0 and 2.');\n    }\n    // Validate maxTokens based on the model's token limits\n    const { min, max } = _const_js__WEBPACK_IMPORTED_MODULE_3__.TOKEN_LIMITS[config.model];\n    if (config.maxTokens < min || config.maxTokens > max) {\n      throw new Error(`AiAssist: maxTokens must be a number between ${min} and ${max}.`);\n    }\n  }\n  init() {\n    // Any additional initialization if needed\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/aiassist.js?")},"./js/ckeditor5_plugins/aiassist/src/aiassistcommand.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (/* binding */ AiAssistCommand)\n/* harmony export */ });\n/* harmony import */ var ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ckeditor5/src/core */ "ckeditor5/src/core.js");\n\nclass AiAssistCommand extends ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__.Command {\n  /**\n   * Creates an instance of the AiAssistCommand.\n   *\n   * @param editor - The editor instance to which this command belongs.\n   * @param aiAssistService - The service instance that handles AI assist functionality.\n   */\n  constructor(editor, aiAssistService) {\n    super(editor);\n    this.aiAssistService = aiAssistService;\n  }\n  /**\n   * Checks whether the command can be executed based on the current selection.\n   *\n   * @returns A boolean indicating if the command can be executed.\n   */\n  refresh() {\n    // Enable the command when the selection is in an empty block or at the beginning of a block\n    this.isEnabled = true;\n  }\n  /**\n   * Executes the AI assist command, processing the user\'s input and interacting with the AI service.\n   *\n   * @param options - An optional parameter for additional execution options.\n   */\n  async execute() {\n    await this.aiAssistService.handleSlashCommand();\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/aiassistcommand.js?')},"./js/ckeditor5_plugins/aiassist/src/aiassistcontext.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AiAssistContext: () => (/* binding */ AiAssistContext),\n/* harmony export */   aiAssistContext: () => (/* binding */ aiAssistContext)\n/* harmony export */ });\n/**\n * The AiAssistContext class provides a context for the AI Assist plugin,\n * allowing access to shared resources and state across different components.\n */\nclass AiAssistContext {\n  constructor() { }\n  static getInstance() {\n    if (!AiAssistContext.instance) {\n      AiAssistContext.instance = new AiAssistContext();\n    }\n    return AiAssistContext.instance;\n  }\n  set uiComponent(component) {\n    this._uiComponent = component;\n  }\n  showError(message) {\n    if (this._uiComponent) {\n      console.log('Showing error message...', message);\n      this._uiComponent.showGptErrorToolTip(message);\n    }\n  }\n  showLoader(rect) {\n    if (this._uiComponent) {\n      this._uiComponent.showLoader(rect);\n    }\n  }\n  hideLoader() {\n    if (this._uiComponent) {\n      this._uiComponent.hideLoader();\n    }\n  }\n}\nconst aiAssistContext = AiAssistContext.getInstance();\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/aiassistcontext.js?")},"./js/ckeditor5_plugins/aiassist/src/aiassistediting.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AiAssistEditing)\n/* harmony export */ });\n/* harmony import */ var ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ckeditor5/src/core */ \"ckeditor5/src/core.js\");\n/* harmony import */ var _aiassistcommand_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aiassistcommand.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistcommand.js\");\n/* harmony import */ var _aiassistservice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aiassistservice.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistservice.js\");\n\n\n\nclass AiAssistEditing extends ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  static get pluginName() {\n    return 'AiAssistEditing';\n  }\n  /**\n   * Initializes the AI Assist editing plugin, setting up commands and key handling.\n   */\n  init() {\n    const editor = this.editor;\n    const aiAssistService = new _aiassistservice_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](editor);\n    editor.commands.add('aiAssist', new _aiassistcommand_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](editor, aiAssistService));\n    this.setupEnterKeyHandling();\n  }\n  /**\n   * Sets up handling for the Enter key to trigger AI assist functionality.\n   * If the content starts with a slash, it cancels the default action and executes the AI assist command.\n   */\n  setupEnterKeyHandling() {\n    const editor = this.editor;\n    const model = editor.model;\n    const mapper = editor.editing.mapper;\n    const view = editor.editing.view;\n    editor.keystrokes.set('enter', async (_, cancel) => {\n      var _a;\n      const position = model.document.selection.getFirstPosition();\n      if (position) {\n        const paragraph = position.parent;\n        const inlineSlash = Array.from(paragraph.getChildren()).find((child) => child.name === 'inline-slash');\n        const equivalentView = mapper.toViewElement(paragraph);\n        let content;\n        if (equivalentView) {\n          content =\n            (_a = view.domConverter.mapViewToDom(equivalentView)) === null || _a === void 0 ? void 0 : _a.innerText;\n        }\n        if ((typeof content === 'string' && content.startsWith('/')) || inlineSlash) {\n          cancel();\n          await editor.execute('aiAssist');\n        }\n      }\n    });\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/aiassistediting.js?")},"./js/ckeditor5_plugins/aiassist/src/aiassistservice.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AiAssistService)\n/* harmony export */ });\n/* harmony import */ var _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aiassistcontext.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistcontext.js\");\n/* harmony import */ var _util_prompt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/prompt.js */ \"./js/ckeditor5_plugins/aiassist/src/util/prompt.js\");\n/* harmony import */ var _util_htmlparser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/htmlparser.js */ \"./js/ckeditor5_plugins/aiassist/src/util/htmlparser.js\");\n\n\n\nclass AiAssistService {\n  /**\n   * Initializes the AiAssistService with the provided editor and configuration settings.\n   *\n   * @param editor - The CKEditor instance to be used with the AI assist service.\n   */\n  constructor(editor) {\n    var _a, _b;\n    this.aiAssistFeatureLockId = Symbol('ai-assist-feature');\n    this.buffer = '';\n    this.openTags = [];\n    this.isInlineInsertion = false;\n    this.editor = editor;\n    this.promptHelper = new _util_prompt_js__WEBPACK_IMPORTED_MODULE_1__.PromptHelper(editor);\n    this.htmlParser = new _util_htmlparser_js__WEBPACK_IMPORTED_MODULE_2__.HtmlParser(editor);\n    const config = editor.config.get('aiAssist');\n    this.aiModel = config.model;\n    this.apiKey = config.apiKey;\n    this.endpointUrl = config.endpointUrl;\n    this.temperature = config.temperature;\n    this.timeOutDuration = (_a = config.timeOutDuration) !== null && _a !== void 0 ? _a : 45000;\n    this.maxTokens = config.maxTokens;\n    this.retryAttempts = config.retryAttempts;\n    this.stopSequences = config.stopSequences;\n    this.streamContent = (_b = config.streamContent) !== null && _b !== void 0 ? _b : true;\n  }\n  /**\n   * Handles the slash command input from the user, processes it, and interacts with the AI model.\n   *\n   * @returns A promise that resolves when the command has been processed.\n   */\n  async handleSlashCommand() {\n    const editor = this.editor;\n    const model = editor.model;\n    const mapper = editor.editing.mapper;\n    const view = editor.editing.view;\n    const root = model.document.getRoot();\n    let content;\n    let parentEquivalentHTML;\n    let parent;\n    const position = model.document.selection.getLastPosition();\n    if (position && root) {\n      parent = position.parent;\n      const inlineSlash = parent.name === 'inline-slash' ? parent : undefined;\n      const equivalentView = mapper.toViewElement(parent);\n      parentEquivalentHTML = equivalentView ? view.domConverter.mapViewToDom(equivalentView) : undefined;\n      if (inlineSlash) {\n        this.isInlineInsertion = true;\n        const startingPath = inlineSlash.getPath();\n        const endingPath = position === null || position === void 0 ? void 0 : position.path;\n        const startPosition = model.createPositionFromPath(root, startingPath); // Example path\n        const endPosition = model.createPositionFromPath(root, endingPath); // Example path\n        const range = model.createRange(startPosition, endPosition);\n        parentEquivalentHTML = (equivalentView === null || equivalentView === void 0 ? void 0 : equivalentView.parent) ?\n          view.domConverter.mapViewToDom(equivalentView.parent) :\n          undefined;\n        content = '';\n        for (const item of range.getItems()) {\n          if (item.is('$textProxy')) {\n            content += item.data.trim(); // Add text data\n          }\n        }\n      }\n      else if (parentEquivalentHTML) {\n        content = parentEquivalentHTML === null || parentEquivalentHTML === void 0 ? void 0 : parentEquivalentHTML.innerText;\n      }\n    }\n    try {\n      const domSelection = window.getSelection();\n      const domRange = domSelection === null || domSelection === void 0 ? void 0 : domSelection.getRangeAt(0);\n      const rect = domRange.getBoundingClientRect();\n      _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_0__.aiAssistContext.showLoader(rect);\n      const gptPrompt = await this.generateGptPromptBasedOnUserPrompt(content !== null && content !== void 0 ? content : '', parentEquivalentHTML === null || parentEquivalentHTML === void 0 ? void 0 : parentEquivalentHTML.innerText);\n      if (parent && gptPrompt) {\n        await this.fetchAndProcessGptResponse(gptPrompt, parent);\n      }\n    }\n    catch (error) {\n      console.error('Error handling slash command:', error);\n      throw error;\n    }\n    finally {\n      this.isInlineInsertion = false;\n      _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_0__.aiAssistContext.hideLoader();\n    }\n  }\n  /**\n   * Fetches and processes the GPT response based on the provided prompt and parent element.\n   *\n   * @param prompt - The prompt to send to the GPT model.\n   * @param parent - The parent element in the editor where the response will be inserted.\n   * @param retries - The number of retry attempts for the API call (default is the configured retry attempts).\n   * @returns A promise that resolves when the response has been processed.\n   */\n  async fetchAndProcessGptResponse(prompt, parent, retries = this.retryAttempts) {\n    var _a, _b, _c;\n    console.log('Starting fetchAndProcessGptResponse');\n    const editor = this.editor;\n    const t = editor.t;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeOutDuration);\n    let buffer = '';\n    let contentBuffer = '';\n    try {\n      const response = await fetch(this.endpointUrl, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          model: this.aiModel,\n          messages: [\n            { role: 'system', content: this.promptHelper.getSystemPrompt(this.isInlineInsertion) },\n            { role: 'user', content: prompt }\n          ],\n          temperature: this.temperature,\n          max_tokens: this.maxTokens,\n          stop: this.stopSequences,\n          stream: true\n        }),\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        throw new Error('Fetch failed');\n      }\n      _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_0__.aiAssistContext.hideLoader();\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder('utf-8');\n      this.clearParentContent(parent);\n      this.editor.enableReadOnlyMode(this.aiAssistFeatureLockId);\n      console.log('Starting to process response');\n      for (;;) {\n        const { done, value } = await reader.read();\n        if (done) {\n          console.log('Finished reading response');\n          break;\n        }\n        const chunk = decoder.decode(value, { stream: true });\n        buffer += chunk;\n        let newlineIndex;\n        while ((newlineIndex = buffer.indexOf('\\n')) !== -1) {\n          const line = buffer.slice(0, newlineIndex).trim();\n          buffer = buffer.slice(newlineIndex + 1);\n          if (line.startsWith('data: ')) {\n            const jsonStr = line.slice(5).trim();\n            if (jsonStr === '[DONE]') {\n              console.log('Received [DONE] signal');\n              break;\n            }\n            try {\n              const data = JSON.parse(jsonStr);\n              const content = (_b = (_a = data.choices[0]) === null || _a === void 0 ? void 0 : _a.delta) === null || _b === void 0 ? void 0 : _b.content;\n              if (content) {\n                contentBuffer += content;\n                if (this.htmlParser.isCompleteHtmlChunk(contentBuffer)) {\n                  await this.processContent(contentBuffer, parent);\n                  contentBuffer = '';\n                }\n              }\n            }\n            catch (parseError) {\n              console.warn('Error parsing JSON:', parseError);\n            }\n          }\n        }\n      }\n      // Process any remaining content in the buffer\n      if (contentBuffer.trim()) {\n        await this.processContent(contentBuffer.trim(), parent);\n      }\n    }\n    catch (error) {\n      console.error('Error in fetchAndProcessGptResponse:', error);\n      const errorIdentifier = ((error === null || error === void 0 ? void 0 : error.message) || '').trim() || ((error === null || error === void 0 ? void 0 : error.name) || '').trim();\n      const isRetryableError = [\n        'AbortError',\n        'ReadableStream not supported',\n        'AiAssist: Fetch failed'\n      ].includes(errorIdentifier);\n      if (retries > 0 && isRetryableError) {\n        console.warn(`Retrying... (${retries} attempts left)`);\n        return await this.fetchAndProcessGptResponse(prompt, parent, retries - 1);\n      }\n      let errorMessage;\n      switch ((error === null || error === void 0 ? void 0 : error.name) || ((_c = error === null || error === void 0 ? void 0 : error.message) === null || _c === void 0 ? void 0 : _c.trim())) {\n        case 'ReadableStream not supported':\n          errorMessage = t('Browser does not support readable streams');\n          break;\n        case 'AiAssist: Fetch failed':\n          errorMessage = t('We couldn\\'t connect to the AI. Please check your internet');\n          break;\n        default:\n          errorMessage = t('We couldn\\'t connect to the AI. Please check your internet');\n      }\n      _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_0__.aiAssistContext.showError(errorMessage);\n    }\n    finally {\n      this.editor.disableReadOnlyMode(this.aiAssistFeatureLockId);\n    }\n  }\n  /**\n   * Processes the provided content and inserts it into the specified parent element.\n   * Depending on the feature flag, it either uses a simple HTML insertion method\n   * or processes the content as HTML.\n   *\n   * @param content - The content to be processed and inserted.\n   * @param parent - The parent element in the editor where the content will be inserted.\n   */\n  async processContent(content, parent) {\n    try {\n      console.log('--- Start of processContent ---');\n      console.log('Processing content:', content, this.isInlineInsertion);\n      if (this.isInlineInsertion) {\n        const position = this.editor.model.document.selection.getLastPosition();\n        const tempParagraph = document.createElement('div');\n        tempParagraph.innerHTML = content;\n        await this.htmlParser.insertSimpleHtml(content);\n      }\n      else {\n        if (this.streamContent) {\n          // Existing complex content processing logic\n          await this.proceedHtmlResponse(content);\n        }\n        else {\n          // Use the simple HTML insertion method\n          await this.htmlParser.insertSimpleHtml(content);\n        }\n      }\n      console.log('--- End of processContent ---');\n    }\n    catch (error) {\n      console.error(error);\n    }\n  }\n  /**\n   * Processes the provided HTML string and inserts its content into the editor.\n   * It creates a temporary div to parse the HTML and handles different types of\n   * elements (lists, tables, headings, etc.) accordingly.\n   *\n   * @param html - The HTML string to be processed and inserted into the editor.\n   */\n  async proceedHtmlResponse(html) {\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = html;\n    for (const child of Array.from(tempDiv.childNodes)) {\n      const element = child;\n      if (element.nodeType === Node.ELEMENT_NODE) {\n        const elementName = element.tagName.toLowerCase();\n        const isStreamingNotAllow = [\n          'table', 'blockquote', 'pre', 'img', 'form', 'figure'\n        ].includes(elementName);\n        if (isStreamingNotAllow) {\n          await this.htmlParser.insertSimpleHtml(element.outerHTML);\n        }\n        else if (elementName === 'ul' || elementName === 'ol') {\n          await this.htmlParser.insertAsText(element, undefined, true, true);\n        }\n        else {\n          await this.htmlParser.insertAsText(element, undefined, true);\n        }\n      }\n      else if (element.nodeType === Node.TEXT_NODE && element.textContent) {\n        const tempParagraph = document.createElement('div');\n        tempParagraph.innerText = element.textContent;\n        await this.htmlParser.insertAsText(tempParagraph, undefined, true);\n      }\n    }\n  }\n  /**\n   * Clears the content of the specified parent element in the editor.\n   *\n   * @param parent - The parent element whose content will be cleared.\n   */\n  clearParentContent(parent) {\n    const editor = this.editor;\n    const model = editor.model;\n    const root = model.document.getRoot();\n    const position = model.document.selection.getLastPosition();\n    const inlineSlash = Array.from(parent.getChildren()).find((child) => child.name === 'inline-slash');\n    if (root && position) {\n      editor.model.change(writer => {\n        const startingPath = (inlineSlash === null || inlineSlash === void 0 ? void 0 : inlineSlash.getPath()) || parent.getPath();\n        const range = model.createRange(model.createPositionFromPath(root, startingPath), model.createPositionFromPath(root, position.path));\n        writer.remove(range);\n        writer.setSelection(model.createPositionFromPath(root, startingPath));\n      });\n    }\n  }\n  /**\n   * Generates a GPT prompt based on the user's input and the current context in the editor.\n   * This method processes the input prompt, extracts any URLs, and formats the final prompt\n   * to be sent to the GPT model. It also handles the case where the editor is empty.\n   *\n   * @param prompt - The user's input prompt, typically starting with a slash.\n   * @param promptContainerText - Optional text from the container that may provide additional context.\n   * @returns A promise that resolves to the generated GPT prompt string or null if an error occurs.\n   */\n  async generateGptPromptBasedOnUserPrompt(prompt, promptContainerText) {\n    try {\n      const context = this.promptHelper.trimContext(prompt, promptContainerText);\n      const request = prompt.slice(1); // Remove the leading slash\n      let markDownContents = [];\n      const urlRegex = /https?:\\/\\/[^\\s/$.?#].[^\\s]*/g;\n      const urls = prompt.match(urlRegex);\n      if (Array.isArray(urls) && urls.length) {\n        const formattedUrl = urls.map(url => {\n          return url.replace(/[,.]$/, '');\n        });\n        markDownContents = await this.promptHelper.generateMarkDownForUrls(formattedUrl);\n        markDownContents = this.promptHelper.allocateTokensToFetchedContent(prompt, markDownContents);\n      }\n      const isEditorEmpty = context === '\"@@@cursor@@@\"';\n      return this.promptHelper.formatFinalPrompt(request, context, markDownContents, isEditorEmpty);\n    }\n    catch (error) {\n      console.error(error);\n      return null;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/aiassistservice.js?")},"./js/ckeditor5_plugins/aiassist/src/aiassistui.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AiAssistUI)\n/* harmony export */ });\n/* harmony import */ var ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ckeditor5/src/core */ \"ckeditor5/src/core.js\");\n/* harmony import */ var ckeditor5_src_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ckeditor5/src/ui */ \"ckeditor5/src/ui.js\");\n/* harmony import */ var _icons_ai_assist_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../icons/ai-assist.svg */ \"./icons/ai-assist.svg\");\n/* harmony import */ var _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aiassistcontext.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistcontext.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./const.js */ \"./js/ckeditor5_plugins/aiassist/src/const.js\");\n\n\n\n\n\nclass AiAssistUI extends ckeditor5_src_core__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n  constructor() {\n    super(...arguments);\n    this.PLACEHOLDER_TEXT_ID = 'slash-placeholder';\n    this.GPT_RESPONSE_LOADER_ID = 'gpt-response-loader';\n    this.GPT_RESPONSE_ERROR_ID = 'gpt-error';\n  }\n  static get pluginName() {\n    return 'AiAssistUI';\n  }\n  /**\n   * Initializes the AI Assist UI plugin, setting up UI components and event listeners.\n   * This method is called when the plugin is loaded.\n   */\n  init() {\n    try {\n      _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_3__.aiAssistContext.uiComponent = this;\n      // Initialize UI components like buttons, placeholders, loaders, etc.\n      this.initializeUIComponents();\n      // Set displays content in the appropriate language.\n      this.initializeUILanguage();\n      // Attach event listeners for handling editor events and user interactions\n      this.attachListener();\n    }\n    catch (error) {\n      console.error(error.message);\n    }\n  }\n  /**\n   * Initializes UI components such as placeholders, loaders, and buttons for the editor.\n   */\n  initializeUIComponents() {\n    const editor = this.editor;\n    const t = editor.t;\n    // Register the inline-slash schema\n    editor.model.schema.register('inline-slash', {\n      inheritAllFrom: '$block',\n      isInline: true,\n      isObject: true,\n      allowWhere: '$text',\n      allowAttributes: ['class']\n    });\n    // Allow the inline-slash element to have text inside it\n    editor.model.schema.extend('$text', {\n      allowIn: 'inline-slash'\n    });\n    // Set up upcast conversion for inline-slash\n    editor.conversion.for('upcast').elementToElement({\n      view: {\n        name: 'inline-slash',\n        attributes: ['class']\n      },\n      model: (viewElement, { writer }) => {\n        return writer.createElement('inline-slash', {\n          class: viewElement.getAttribute('class')\n        });\n      },\n      converterPriority: 'high'\n    });\n    editor.conversion.for('downcast').elementToElement({\n      model: {\n        name: 'inline-slash',\n        attributes: ['class']\n      },\n      view: (modelElement, { writer }) => {\n        return writer.createContainerElement('inline-slash', {\n          class: modelElement.getAttribute('class')\n        });\n      }\n    });\n    this.addLoader();\n    this.addGptErrorToolTip();\n    editor.ui.componentFactory.add('AiAssist', locale => {\n      const dropdownView = (0,ckeditor5_src_ui__WEBPACK_IMPORTED_MODULE_1__.createDropdown)(locale, ckeditor5_src_ui__WEBPACK_IMPORTED_MODULE_1__.SplitButtonView);\n      const view = new ckeditor5_src_ui__WEBPACK_IMPORTED_MODULE_1__.ButtonView(locale);\n      // const view =  dropdownView.buttonView;\n      view.set({\n        label: t('Ai assist'),\n        icon: _icons_ai_assist_svg__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        tooltip: true\n      });\n      view.on('execute', () => {\n        this.editor.model.change(writer => {\n          const position = this.editor.model.document.selection.getLastPosition();\n          if (position) {\n            const inlineSlashContainer = writer.createElement('inline-slash', { class: 'ck-slash' });\n            writer.insertText('/', inlineSlashContainer);\n            writer.insert(inlineSlashContainer, position);\n            const newPosition = writer.createPositionAt(inlineSlashContainer, 'end');\n            writer.setSelection(newPosition);\n          }\n        });\n        editor.editing.view.focus();\n      });\n      return view;\n    });\n  }\n  /**\n   * Initializes the UI language settings based on the editor's locale.\n   * Displays an error tooltip if the current language is unsupported.\n   */\n  initializeUILanguage() {\n    const editor = this.editor;\n    const t = editor.t;\n    const contentLanguageCode = editor.locale.contentLanguage;\n    const supportedLanguages = _const_js__WEBPACK_IMPORTED_MODULE_4__.SUPPORTED_LANGUAGES;\n    if (!supportedLanguages.includes(contentLanguageCode)) {\n      this.showGptErrorToolTip(t('Unsupported language code'));\n    }\n  }\n  /**\n   * Attaches event listeners to the editor for handling user interactions and content changes.\n   */\n  attachListener() {\n    const editor = this.editor;\n    const model = editor.model;\n    model.document.on('change:data', () => {\n      setTimeout(() => {\n        this.applyPlaceholderToCurrentLine();\n      }, 10);\n    });\n    model.document.selection.on('change:range', () => {\n      setTimeout(() => {\n        this.applyPlaceholderToCurrentLine();\n      }, 10);\n      const modelRoot = editor.model.document.getRoot();\n      if (modelRoot) {\n        const modelRange = editor.model.createRangeIn(modelRoot);\n        const itemsToRemove = [];\n        for (const item of modelRange.getItems()) {\n          if (item.is('element', 'inline-slash') && item.isEmpty) {\n            itemsToRemove.push(item); // Collect empty items\n          }\n        }\n        // Remove collected empty inline-slash elements\n        editor.model.change(writer => {\n          for (const item of itemsToRemove) {\n            writer.remove(item);\n          }\n        });\n      }\n    });\n    editor.editing.view.document.on('scroll', () => {\n      this.hidePlaceHolder();\n    });\n    document.addEventListener('scroll', () => {\n      this.hidePlaceHolder();\n    });\n  }\n  /**\n   * Applies the placeholder to the current line in the editor if it is empty.\n   * Hides the placeholder if the line is not empty.\n   */\n  applyPlaceholderToCurrentLine() {\n    var _a;\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const block = (_a = modelSelection.getFirstPosition()) === null || _a === void 0 ? void 0 : _a.parent;\n    if (block && block.isEmpty) {\n      this.hidePlaceHolder();\n      setTimeout(async () => {\n        if (block.is('element')) {\n          const rect = await this.getRectDomOfGivenModelElement(block);\n          if (rect) {\n            this.showPlaceHolder(rect);\n          }\n        }\n      }, 100);\n    }\n    else {\n      this.hidePlaceHolder();\n    }\n  }\n  /**\n   * Retrieves the DOM rectangle of a given model element.\n   *\n   * @param element - The model element for which to get the DOM rectangle.\n   * @returns A promise that resolves to the DOMRect of the element, or null if not found.\n   */\n  async getRectDomOfGivenModelElement(element) {\n    const editor = this.editor;\n    const mapper = editor.editing.mapper;\n    const view = editor.editing.view;\n    const equivalentView = mapper.toViewElement(element);\n    if (equivalentView) {\n      const domElement = view.domConverter.mapViewToDom(equivalentView);\n      if (domElement) {\n        return domElement.getBoundingClientRect();\n      }\n    }\n    return null;\n  }\n  /**\n   * Adds a placeholder element to the document body for user interaction.\n   */\n  addPlaceholder() {\n    const editor = this.editor;\n    const t = editor.t;\n    const placeholder = document.createElement('p');\n    placeholder.id = this.PLACEHOLDER_TEXT_ID;\n    placeholder.onclick = () => {\n      editor.focus();\n    };\n    placeholder.classList.add('place-holder');\n    placeholder.textContent = t('Type / to request AI content');\n    document.body.appendChild(placeholder);\n  }\n  /**\n   * Shows the placeholder at the specified position.\n   *\n   * @param rect - The DOMRect object defining the position to show the placeholder.\n   */\n  showPlaceHolder(rect) {\n    const ele = document.getElementById(this.PLACEHOLDER_TEXT_ID);\n    const isReadOnlyMode = this.editor.isReadOnly;\n    if (ele && rect && !isReadOnlyMode) {\n      ele.classList.add('show-place-holder');\n      ele.style.left = `${rect.left}px`;\n      ele.style.top = `${rect.top}px`;\n    }\n    else if (ele) {\n      ele.classList.remove('show-place-holder');\n    }\n  }\n  /**\n   * Hides the placeholder element from the document.\n   */\n  hidePlaceHolder() {\n    const ele = document.getElementById(this.PLACEHOLDER_TEXT_ID);\n    if (ele) {\n      ele.classList.remove('show-place-holder');\n    }\n  }\n  /**\n   * Adds a loader element to the document body for indicating processing.\n   */\n  addLoader() {\n    const loaderElement = document.createElement('div');\n    loaderElement.id = this.GPT_RESPONSE_LOADER_ID;\n    loaderElement.classList.add('gpt-loader');\n    document.body.appendChild(loaderElement);\n  }\n  /**\n   * Shows the loader at the specified position.\n   *\n   * @param rect - The DOMRect object defining the position to show the loader.\n   */\n  showLoader(rect) {\n    const ele = document.getElementById(this.GPT_RESPONSE_LOADER_ID);\n    if (ele && rect) {\n      ele.style.left = `${rect.left + 10}px`;\n      ele.style.top = `${rect.top + 10}px`;\n      ele.classList.add('show-gpt-loader');\n    }\n    else if (ele) {\n      ele.classList.remove('show-gpt-loader');\n    }\n  }\n  /**\n   * Hides the loader element from the document.\n   */\n  hideLoader() {\n    const ele = document.getElementById(this.GPT_RESPONSE_LOADER_ID);\n    if (ele) {\n      ele.classList.remove('show-gpt-loader');\n    }\n  }\n  /**\n   * Adds an error tooltip element to the document body for displaying error messages.\n   */\n  addGptErrorToolTip() {\n    const tooltipElement = document.createElement('p');\n    tooltipElement.id = this.GPT_RESPONSE_ERROR_ID;\n    tooltipElement.classList.add('response-error');\n    document.body.appendChild(tooltipElement);\n  }\n  /**\n   * Displays an error tooltip with the specified message.\n   *\n   * @param message - The error message to display in the tooltip.\n   */\n  showGptErrorToolTip(message) {\n    var _a, _b, _c;\n    console.log('Showing error message...', message);\n    const editor = this.editor;\n    const view = (_c = (_b = (_a = editor === null || editor === void 0 ? void 0 : editor.editing) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.domRoots) === null || _c === void 0 ? void 0 : _c.get('main');\n    const tooltipElement = document.getElementById(this.GPT_RESPONSE_ERROR_ID);\n    const editorRect = view === null || view === void 0 ? void 0 : view.getBoundingClientRect();\n    if (tooltipElement && editorRect) {\n      tooltipElement.classList.add('show-response-error');\n      tooltipElement.textContent = message;\n      setTimeout(() => {\n        this.hideGptErrorToolTip();\n      }, 2000);\n    }\n  }\n  /**\n   * Hides the error tooltip element from the document.\n   */\n  hideGptErrorToolTip() {\n    const tooltipElement = document.getElementById(this.GPT_RESPONSE_ERROR_ID);\n    if (tooltipElement) {\n      tooltipElement.classList.remove('show-response-error');\n    }\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/aiassistui.js?")},"./js/ckeditor5_plugins/aiassist/src/const.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SUPPORTED_LANGUAGES: () => (/* binding */ SUPPORTED_LANGUAGES),\n/* harmony export */   TOKEN_LIMITS: () => (/* binding */ TOKEN_LIMITS)\n/* harmony export */ });\n// const\nconst TOKEN_LIMITS = {\n  'gpt-3': { min: 1, max: 4096, context: 16385 },\n  'gpt-3.5-turbo': { min: 1, max: 4096, context: 16385 },\n  'gpt-4': { min: 1, max: 4096, context: 128000 },\n  'gpt-4o': { min: 0, max: 4096, context: 128000 },\n  'gpt-4-turbo': { min: 1, max: 4096, context: 128000 },\n  'gpt-4o-mini': { min: 1, max: 4096, context: 128000 },\n  'kavya-m1': { min: 0, max: 4096, context: 128000 }\n};\nconst SUPPORTED_LANGUAGES = ['en', 'es', 'hi', 'nl'];\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/const.js?")},"./js/ckeditor5_plugins/aiassist/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _aiassist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aiassist */ "./js/ckeditor5_plugins/aiassist/src/aiassist.js");\n/**\n * @file The build process always expects an index.js file. Anything exported\n * here will be recognized by CKEditor 5 as an available plugin. Multiple\n * plugins can be exported in this one file.\n *\n * I.e. this file\'s purpose is to make plugin(s) discoverable.\n */\n// cSpell:ignore simplebox\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  AiAssist: _aiassist__WEBPACK_IMPORTED_MODULE_0__["default"],\n});\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/index.js?')},"./js/ckeditor5_plugins/aiassist/src/util/htmlparser.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HtmlParser: () => (/* binding */ HtmlParser)\n/* harmony export */ });\nclass HtmlParser {\n  constructor(editor) {\n    this.editor = editor;\n    this.model = editor.model;\n  }\n  /**\n   * Inserts simple HTML content into the editor.\n   *\n   * @param html - The HTML string to be inserted into the editor.\n   * @returns A promise that resolves when the HTML has been inserted.\n   */\n  async insertSimpleHtml(html) {\n    var _a;\n    console.log('Attempting to insert simple HTML:', html);\n    const viewFragment = this.editor.data.processor.toView(html);\n    const modelFragment = this.editor.data.toModel(viewFragment, '$root');\n    const selection = this.model.document.selection;\n    const root = this.model.document.getRoot();\n    let insertionPosition = selection.getLastPosition();\n    const lastInsertedChild = modelFragment.getChild(modelFragment.childCount - 1);\n    const currentChildIndex = (_a = selection.getLastPosition()) === null || _a === void 0 ? void 0 : _a.path[0];\n    const lastUpdatedElementInRoot = root === null || root === void 0 ? void 0 : root.getChild(currentChildIndex !== null && currentChildIndex !== void 0 ? currentChildIndex : 0);\n    this.model.change(writer => {\n      if (lastUpdatedElementInRoot === null || lastUpdatedElementInRoot === void 0 ? void 0 : lastUpdatedElementInRoot.is('element')) {\n        insertionPosition = lastUpdatedElementInRoot.isEmpty ?\n          writer.createPositionAt(lastUpdatedElementInRoot, 'end') :\n          writer.createPositionAfter(lastUpdatedElementInRoot);\n      }\n      if (insertionPosition && root) {\n        // Insert element to current selection\n        writer.setSelection(insertionPosition);\n        this.model.insertContent(modelFragment, insertionPosition);\n        // Check if it required to add break to current context of list etc.\n        // More to will be added during testing any edge case\n        let isBreakElementReq = lastInsertedChild === null || lastInsertedChild === void 0 ? void 0 : lastInsertedChild.getAttribute('listItemId');\n        if (lastInsertedChild === null || lastInsertedChild === void 0 ? void 0 : lastInsertedChild.is('element')) {\n          isBreakElementReq = isBreakElementReq || lastInsertedChild.name === 'table';\n        }\n        if (isBreakElementReq && lastInsertedChild) {\n          const paragraph = writer.createElement('paragraph');\n          writer.insert(paragraph, writer.createPositionAfter(lastInsertedChild));\n          writer.setSelection(paragraph, 'in');\n        }\n        else if (lastInsertedChild) {\n          writer.setSelection(writer.createPositionAfter(lastInsertedChild));\n        }\n      }\n    });\n    // Maintain a delay to simulate asynchronous behavior\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n  /**\n   * Inserts HTML content as text into the editor.\n   *\n   * @param content - The HTML element containing the text to be inserted.\n   * @param position - The position at which to insert the text (optional).\n   * @param stream - Indicates whether to insert text in a streaming manner (default is false).\n   * @param shouldAddBreakAtEnd - Indicates whether to add a paragraph break at the end of the inserted content (default is false).\n   * @returns A promise that resolves when the text has been inserted.\n   *\n   * This method processes the provided HTML element, converting it to a model fragment,\n   * and inserts it into the editor at the specified position. If streaming is enabled,\n   * elements are inserted one at a time, allowing for a more dynamic insertion experience.\n   * An optional paragraph break can be added at the end of the inserted content.\n   */\n  async insertAsText(content, position, stream = false, shouldAddBreakAtEnd = false) {\n    const viewFragment = this.editor.data.processor.toView(content.outerHTML);\n    const modelFragment = this.editor.data.toModel(viewFragment, '$root');\n    const childrenToInsert = Array.from(modelFragment.getChildren());\n    const root = this.model.document.getRoot();\n    for (const [index, element] of childrenToInsert.entries()) {\n      if (element.is('element')) {\n        const insertPosition = index === 0 ? position : undefined; // Determine position for insertion\n        if (stream) {\n          await this.insertElementAsStream(element, insertPosition);\n        }\n        else {\n          await this.batchInsertOfElement(element, insertPosition);\n        }\n      }\n    }\n    if (shouldAddBreakAtEnd) {\n      this.model.change(writer => {\n        const lastPosition = this.model.document.selection.getLastPosition();\n        const currentChildIndex = lastPosition === null || lastPosition === void 0 ? void 0 : lastPosition.path[0];\n        if (root && currentChildIndex != undefined) {\n          const paragraph = writer.createElement('paragraph');\n          writer.insert(paragraph, root, currentChildIndex + 1);\n          writer.setSelection(paragraph, 'in');\n        }\n      });\n    }\n  }\n  /**\n   * Inserts a given element into the editor at the specified position.\n   *\n   * @param element - The element to be inserted into the editor.\n   * @param position - The position at which to insert the element.\n   * If not provided, the element will be inserted at the current selection position.\n   * @returns A promise that resolves when the element has been inserted.\n   */\n  async batchInsertOfElement(element, position) {\n    var _a;\n    const selection = this.model.document.selection;\n    const root = this.model.document.getRoot();\n    let insertionPosition = position;\n    if (!position) {\n      const currentChildIndex = (_a = selection.getFirstPosition()) === null || _a === void 0 ? void 0 : _a.path[0];\n      const lastUpdatedElementInRoot = root === null || root === void 0 ? void 0 : root.getChild(currentChildIndex !== null && currentChildIndex !== void 0 ? currentChildIndex : 0);\n      if (lastUpdatedElementInRoot === null || lastUpdatedElementInRoot === void 0 ? void 0 : lastUpdatedElementInRoot.is('element')) {\n        insertionPosition = lastUpdatedElementInRoot.isEmpty ?\n          this.model.createPositionAt(lastUpdatedElementInRoot, 'end') :\n          this.model.createPositionAfter(lastUpdatedElementInRoot);\n      }\n    }\n    // insert content at current identified position\n    this.model.change(writer => {\n      this.model.insertContent(element, insertionPosition);\n      writer.setSelection(element, 'end');\n    });\n  }\n  /**\n   * Inserts a given element into the editor at the specified position in a streaming manner.\n   *\n   * @param element - The element to be inserted into the editor.\n   * @param position - The position at which to insert the element.\n   * If not provided, the element will be inserted at the current selection position.\n   * @returns A promise that resolves when the element has been inserted and all text has been streamed in.\n   */\n  async insertElementAsStream(element, position) {\n    const selection = this.model.document.selection;\n    const root = this.model.document.getRoot();\n    const lastRecognizedPosition = selection.getLastPosition();\n    let insertionPosition = position;\n    let targetElement;\n    // Determine insertion position\n    if (!position) {\n      const currentChildIndex = lastRecognizedPosition === null || lastRecognizedPosition === void 0 ? void 0 : lastRecognizedPosition.path[0];\n      const lastUpdatedElement = root === null || root === void 0 ? void 0 : root.getChild(currentChildIndex !== null && currentChildIndex !== void 0 ? currentChildIndex : 0);\n      if (lastUpdatedElement === null || lastUpdatedElement === void 0 ? void 0 : lastUpdatedElement.is('element')) {\n        insertionPosition = lastUpdatedElement.isEmpty ?\n          this.model.createPositionAt(lastUpdatedElement, 'end') :\n          this.model.createPositionAfter(lastUpdatedElement);\n      }\n      this.model.change(writer => {\n        targetElement = writer.createElement(element.name);\n        // Set attributes in a more concise way\n        for (const [key, value] of element.getAttributes()) {\n          targetElement._setAttribute(key, value);\n        }\n        this.model.insertContent(targetElement, insertionPosition);\n        if (insertionPosition) {\n          writer.setSelection(targetElement, 'end');\n        }\n      });\n    }\n    else {\n      // current element from the offset\n      const currentElement = lastRecognizedPosition === null || lastRecognizedPosition === void 0 ? void 0 : lastRecognizedPosition.parent;\n      if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.is('element')) {\n        targetElement = currentElement;\n      }\n    }\n    const textChildren = Array.from(element.getChildren()).filter(child => child.is('$text'));\n    for (const textNode of textChildren) {\n      if (!textNode.is('$text')) {\n        continue;\n      }\n      const textAttributes = Array.from(textNode.getAttributes());\n      const textContent = textNode._data;\n      for (const char of textContent) {\n        await new Promise(resolve => {\n          this.model.change(writer => {\n            const currentPosition = this.editor.model.document.selection.getLastPosition();\n            const newPosition = currentPosition.getShiftedBy(1);\n            const shouldAppendAtEnd = newPosition.offset === (currentPosition === null || currentPosition === void 0 ? void 0 : currentPosition.parent.maxOffset);\n            writer.insertText(char, textAttributes, targetElement, shouldAppendAtEnd ? 'end' : currentPosition === null || currentPosition === void 0 ? void 0 : currentPosition.offset);\n            writer.setSelection(this.editor.model.document.selection.getLastPosition());\n          });\n          setTimeout(resolve, 5); // Maintain the streaming effect\n        });\n      }\n    }\n    // Set selection\n    if (!position) {\n      this.model.change(writer => {\n        writer.setSelection(targetElement, 'end');\n      });\n    }\n  }\n  /**\n   * Validate given string as a HTML content\n   * @param content string containing html content\n   * @returns A boolean value as result of validation\n   */\n  isCompleteHtmlChunk(html) {\n    const openingTags = (html.match(/<[^/][^>]*>/g) || []).length;\n    const closingTags = (html.match(/<\\/[^>]+>/g) || []).length;\n    // Check if all opening tags have corresponding closing tags\n    if (openingTags !== closingTags) {\n      return false;\n    }\n    // Check for incomplete tags\n    if (html.includes('<') && !html.includes('>')) {\n      return false;\n    }\n    // Check if the HTML starts with an opening tag and ends with a closing tag\n    const trimmedHtml = html.trim();\n    if (!trimmedHtml.startsWith('<') || !trimmedHtml.endsWith('>')) {\n      return false;\n    }\n    return true;\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/util/htmlparser.js?")},"./js/ckeditor5_plugins/aiassist/src/util/prompt.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PromptHelper: () => (/* binding */ PromptHelper)\n/* harmony export */ });\n/* harmony import */ var sbd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sbd */ \"./node_modules/sbd/lib/tokenizer.js\");\n/* harmony import */ var _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../aiassistcontext.js */ \"./js/ckeditor5_plugins/aiassist/src/aiassistcontext.js\");\n\n\nclass PromptHelper {\n  constructor(editor) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    this.editor = editor;\n    const config = editor.config.get('aiAssist');\n    this.contextSize = config.contextSize;\n    this.responseOutputFormat = (_b = (_a = config.promptSettings) === null || _a === void 0 ? void 0 : _a.outputFormat) !== null && _b !== void 0 ? _b : [];\n    this.responseContextData = (_d = (_c = config.promptSettings) === null || _c === void 0 ? void 0 : _c.contextData) !== null && _d !== void 0 ? _d : [];\n    this.responseFilters = (_f = (_e = config.promptSettings) === null || _e === void 0 ? void 0 : _e.filters) !== null && _f !== void 0 ? _f : [];\n    this.debugMode = (_g = config.debugMode) !== null && _g !== void 0 ? _g : false;\n  }\n  /**\n   * Constructs the system prompt that guides the AI in generating responses.\n   *\n   * This method assembles a comprehensive set of instructions and context\n   * that the AI will utilize to formulate responses based on user input\n   * and the provided content, ensuring adherence to specified rules and formats.\n   *\n   * @param isInlineResponse - A boolean indicating whether the response should be inline.\n   * @returns A string containing the formatted system prompt for the AI.\n   */\n  getSystemPrompt(isInlineResponse = false) {\n    const corpus = [];\n    corpus.push(`You will be provided with a partially written article with \"\"\"@@@cursor@@@\"\"\" somewhere\n\t\t\tunder a CONTEXT section, user input under a TASK section, and sometimes there will be articles\n\t\t\t(delimited with marked-up language) separated by Starting Markdown Content \\${ number } and\n\t\t\tEnding Markdown Content \\${ index } with certain instructions to follow while generating a response\n\t\t\tunder an INSTRUCTION section`);\n    corpus.push(`If there is an article with \"\"\"Stating Markdown Content\"\"\", your task is to\n\t\t\tuse that provided information solely to respond to the user request in the TASK section.`);\n    corpus.push('Follow these step-by-step instructions to respond to user inputs:');\n    corpus.push(`Step 1 - Summarize information under the CONTEXT section, set a tone for the article, and\n\t\t\tlater use that summarized information to generate a response`);\n    corpus.push(`Step 2: If there is an article with \"\"\"Stating Markdown Content\"\"\",\n\t\t\tbreak it into derived sections and eliminate unnecessary information\n\t\t\tthat does not relate to the context and user prompt.`);\n    corpus.push('Final Step - use all summarized information to respond to user input under the TASK section');\n    corpus.push('While generating the response, adhere to the following rules:');\n    corpus.push(`1. Provide only the new text content that should replace \"@@@cursor@@@\" based on the context above,\n\t\t\tensuring that the response must primarily based on the request.`);\n    corpus.push(`2. Avoid including any part of the context in the output at any cost,\n\t\t\texcept for necessary glimpses that enhance the response.`);\n    corpus.push(`3. Ensure response adheres to the specified tone or style, such as\n\t\t\tformal, informal, or technical, as appropriate for the context.`);\n    corpus.push('4. Do not use any markdown formatting in your response. (e.g., **, ##, ###, ---, ===, ____).');\n    corpus.push(`5. Use a relaxed, formal or informal tone based on the summary of context with lots of personal touches.\n\t\t\tFeel free to include spontaneous thoughts, offhand comments, or quirky observations.`);\n    corpus.push(`6. Vary sentence lengths and stylesinclude fragments, casual interjections,\n\t\t\tand minor grammar slips, but avoid spelling mistakes.`);\n    corpus.push('7. Add in personal anecdotes or emotional reactions to make it sound like a genuine conversation.');\n    corpus.push('8. Avoid overly polished language or structured sentences, aim for a natural and solely human-like tone.');\n    if (isInlineResponse) {\n      corpus.push(`9: Determine from the context, task, and the position of the @@@cursor@@@ whether the request\n\t\t\t\tinvolves list items, table cells, or inline content.\n\t\t\t\t- List items: Format each item as <li> within an <ol> or <ul> as appropriate.\n\t\t\t\t- Table cells: Present each item in plain text, wrapping it within <p> tags.\n\t\t\t\t- Inline content: Wrap entire response in a single <p> tag, ensuring it fits seamlessly within the existing paragraph or\n\t\t\t\tsentence structure where the @@@cursor@@@ is located.\n\t\t\t\tStrictly adherence to these rules is mandatory to avoid errors, based on where the @@@cursor@@@ is placed within content.`);\n    }\n    corpus.push('Above are the rules apply every time, but below will only be applied if markdown content is present');\n    corpus.push('1. Extract each content as plain text without any special formatting, emphasis, or markdown');\n    corpus.push('2. The response should synthesize information from both the editor content ' +\n      'and the fetched sources, maintaining a balance between them.');\n    corpus.push('3. Highlight key points from the fetched sources while ensuring that ' +\n      'the context from the editor is acknowledged and integrated where relevant.');\n    corpus.push('4. Clearly differentiate between the information derived from the editor ' +\n      'content and that from the fetched sources to avoid confusion.');\n    corpus.push('When generating content, adhere to the following HTML-specific rules:');\n    corpus.push('1. Generate an HTML snippet, not a full HTML document.');\n    corpus.push('2. You are an HTML generator. When providing HTML code, ensure it follows standard HTML norms and best practices.');\n    corpus.push('4. Block-level elements (e.g., <p>, <div>, <section>) must not contain other block-level elements.');\n    corpus.push('5. Ensure valid nesting of elements.');\n    corpus.push('6. Use the following allowed HTML tags:');\n    corpus.push(`${this.getAllowedHtmlTags().join(', ')}`);\n    corpus.push('7. Do not include any HTML, HEAD, or BODY tags.');\n    corpus.push('8. Ensure all HTML tags are properly closed and nested.');\n    corpus.push('9. Do not include any HTML, HEAD, or BODY tags.');\n    corpus.push('10. Avoid using inline styles or class attributes unless specifically requested.');\n    corpus.push('11. Provide clean, valid HTML that adheres to best practices and is ready for use in web development.');\n    corpus.push('12. Beginning word of response must be a valid html tag');\n    // Join all instructions into a single formatted string.\n    const systemPrompt = corpus.join('\\n');\n    // Log the system prompt if debug mode is enabled\n    if (this.debugMode) {\n      console.group('AiAssist System Prompt Debug');\n      console.log('System Prompt:');\n      console.log(systemPrompt);\n      console.groupEnd();\n    }\n    return systemPrompt;\n  }\n  /**\n   * Formats the final prompt to be sent to the GPT model, including context and instructions.\n   *\n   * @param request - The user's request string.\n   * @param context - The trimmed context string.\n   * @param markDownContents - An array of MarkdownContent objects for additional context.\n   * @param isEditorEmpty - A boolean indicating if the editor is empty.\n   * @returns The formatted prompt string.\n   */\n  formatFinalPrompt(request, context, markDownContents, isEditorEmpty) {\n    const editor = this.editor;\n    const contentLanguageCode = editor.locale.contentLanguage;\n    const corpus = [];\n    // Context and Task\n    corpus.push('CONTEXT:');\n    corpus.push(`\\n\"\"\"\\n${context}\\n\"\"\"\\n`);\n    corpus.push('\\n\\nTASK:\\n\\n');\n    corpus.push(`\"\"\"\\n${request}\\n\"\"\"\\n`);\n    // Markdown Content\n    if (markDownContents.length) {\n      corpus.push('Refer to following markdown content as a source of information, but generate new text that fits the given context & task.');\n      markDownContents.forEach((markdown, index) => {\n        corpus.push(`\\n\\n------------ Stating Markdown Content ${index + 1} ------------\\n\\n`);\n        corpus.push(markdown.content);\n        corpus.push(`\\n\\n------------ Ending Markdown Content ${index + 1} ------------\\n\\n`);\n      });\n    }\n    // Instructions\n    corpus.push('\\n\\nINSTRUCTIONS:\\n\\n');\n    corpus.push(`The response must follow the language code - ${contentLanguageCode}.`);\n    // Response Output Format\n    if (this.responseOutputFormat.length) {\n      corpus.push(...this.responseOutputFormat);\n    }\n    // Markdown Content Usage\n    if (markDownContents.length) {\n      corpus.push('Use information from provided markdown content to generate new text, but do not copy it verbatim.');\n      corpus.push('Ensure the new text flows naturally with the existing context and integrates smoothly.');\n      corpus.push('Do not use any markdown formatting in your response. ' +\n        'specially for title and list item like \"\"\"**Performance**\"\"\" is not acceptable where as \"\"\"performance\"\"\" is.');\n      corpus.push('consider whole markdown of single source as content and then generate % content requested');\n    }\n    // Response Filters\n    if (this.responseFilters.length) {\n      corpus.push(...this.responseFilters);\n    }\n    else {\n      const defaultFilterInstructions = [\n        'The response should directly follow the context, avoiding any awkward transitions or noticeable gaps.'\n      ];\n      corpus.push(...defaultFilterInstructions);\n    }\n    // Context-Specific Instructions\n    if (!isEditorEmpty) {\n      const defaultContextInstructions = [\n        'Ensure the inserted content maintains a seamless connection with the surrounding text,',\n        'making the transition smooth and natural.',\n        'Do not modify the original text except to replace the \"@@@cursor@@@\" placeholder with the generated content.'\n      ];\n      corpus.push(...defaultContextInstructions);\n    }\n    if (this.responseContextData.length) {\n      corpus.push(...this.responseContextData);\n    }\n    // Debugging Information\n    if (this.debugMode) {\n      console.group('AiAssist Prompt Debug');\n      console.log('User Prompt:', request);\n      console.log('Generated GPT Prompt:');\n      console.log(corpus.join('\\n'));\n      console.groupEnd();\n    }\n    // Join all instructions into a single formatted string.\n    return corpus.join('\\n');\n  }\n  /**\n   * Trims the context around the user's prompt to create a suitable context for the AI model.\n   * This method identifies the position of the user's prompt within the provided text and extracts\n   * the surrounding context, placing a cursor placeholder where the prompt is located.\n   *\n   * @param prompt - The user's prompt string to locate within the context.\n   * @param promptContainerText - The text container in which the prompt is located (optional).\n   * @returns The trimmed context string with a cursor placeholder indicating the prompt's position.\n   */\n  trimContext(prompt, promptContainerText = '') {\n    var _a, _b, _c, _d;\n    let contentBeforePrompt = '';\n    let contentAfterPrompt = '';\n    const splitText = promptContainerText !== null && promptContainerText !== void 0 ? promptContainerText : prompt;\n    const editor = this.editor;\n    const view = (_c = (_b = (_a = editor === null || editor === void 0 ? void 0 : editor.editing) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.domRoots) === null || _c === void 0 ? void 0 : _c.get('main');\n    const context = (_d = view === null || view === void 0 ? void 0 : view.innerText) !== null && _d !== void 0 ? _d : '';\n    const matchIndex = context.indexOf(splitText);\n    const nextEnterIndex = context.indexOf('\\n', matchIndex);\n    const firstNewlineIndex = nextEnterIndex !== -1 ? nextEnterIndex : matchIndex + splitText.length;\n    const beforeNewline = context.substring(0, firstNewlineIndex);\n    const afterNewline = context.substring(firstNewlineIndex + 1);\n    const contextParts = [beforeNewline, afterNewline];\n    const allocatedEditorContextToken = Math.floor(this.contextSize * 0.3);\n    if (contextParts.length > 1) {\n      if (contextParts[0].length < contextParts[1].length) {\n        contentBeforePrompt = this.extractEditorContent(contextParts[0], allocatedEditorContextToken / 2, true);\n        contentAfterPrompt = this.extractEditorContent(contextParts[1], allocatedEditorContextToken - contentBeforePrompt.length / 4);\n      }\n      else {\n        contentAfterPrompt = this.extractEditorContent(contextParts[1], allocatedEditorContextToken / 2);\n        contentBeforePrompt = this.extractEditorContent(contextParts[0], allocatedEditorContextToken - contentAfterPrompt.length / 4, true);\n      }\n    }\n    // Combine the trimmed context with the cursor placeholder\n    const escapedPrompt = prompt.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escapes special characters\n    contentBeforePrompt = contentBeforePrompt.trim().replace(new RegExp(escapedPrompt.slice(1)), '@@@cursor@@@');\n    const trimmedContext = `${contentBeforePrompt}\\n${contentAfterPrompt}`;\n    return trimmedContext.trim();\n  }\n  /**\n   * Allocates tokens to the fetched content based on the available limit and the user's prompt.\n   *\n   * @param prompt - The user's prompt string.\n   * @param fetchedContent - An array of MarkdownContent objects containing fetched content.\n   * @returns An array of MarkdownContent objects with calculated tokenToRequest values.\n   */\n  allocateTokensToFetchedContent(prompt, fetchedContent) {\n    var _a, _b, _c, _d, _e, _f;\n    const editorContent = (_f = (_e = (_d = (_c = (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.editing) === null || _b === void 0 ? void 0 : _b.view) === null || _c === void 0 ? void 0 : _c.domRoots) === null || _d === void 0 ? void 0 : _d.get('main')) === null || _e === void 0 ? void 0 : _e.innerText) !== null && _f !== void 0 ? _f : '';\n    const editorToken = Math.min(Math.floor(this.contextSize * 0.3), this.countTokens(editorContent));\n    let availableLimit = this.contextSize - editorToken;\n    fetchedContent = fetchedContent\n      .map(content => ({\n        ...content,\n        availableToken: this.countTokens(content.content)\n      }))\n      .sort((a, b) => { var _a, _b; return ((_a = a.availableToken) !== null && _a !== void 0 ? _a : 0) - ((_b = b.availableToken) !== null && _b !== void 0 ? _b : 0); });\n    let maxTokenFromEachURL = availableLimit / fetchedContent.length;\n    return fetchedContent.map((content, index) => {\n      if (content.availableToken &&\n        content.availableToken <= maxTokenFromEachURL) {\n        content.tokenToRequest = content.availableToken;\n        availableLimit -= content.availableToken;\n      }\n      else if (content.availableToken) {\n        content.tokenToRequest = maxTokenFromEachURL;\n        availableLimit -= maxTokenFromEachURL;\n      }\n      maxTokenFromEachURL =\n        availableLimit / (fetchedContent.length - (index + 1));\n      if (content.tokenToRequest) {\n        content.content = this.trimLLMContentByTokens(content.content, content.tokenToRequest);\n      }\n      return content;\n    });\n  }\n  /**\n   * Generates Markdown content for an array of URLs by fetching their content.\n   *\n   * @param urls - An array of URLs to fetch content from.\n   * @returns A promise that resolves to an array of MarkdownContent objects.\n   */\n  async generateMarkDownForUrls(urls) {\n    const editor = this.editor;\n    const t = editor.t;\n    let errorMsg;\n    const markDownContents = await Promise.all(urls.map(async (url) => {\n      const content = await this.fetchUrlContent(url);\n      return { content, url };\n    }));\n    const emptyContent = markDownContents.filter((content) => !(content === null || content === void 0 ? void 0 : content.content));\n    if (emptyContent.length) {\n      const urlStr = emptyContent === null || emptyContent === void 0 ? void 0 : emptyContent.map(content => content === null || content === void 0 ? void 0 : content.url).join(',');\n      errorMsg = t('Failed to fetch content of : %0', urlStr);\n      if (errorMsg) {\n        _aiassistcontext_js__WEBPACK_IMPORTED_MODULE_1__.aiAssistContext.showError(errorMsg);\n      }\n      throw new Error('Unable to fetch content for few urls');\n    }\n    return markDownContents.filter((content) => content !== null);\n  }\n  /**\n   * Fetches the content of a given URL and returns it as a string.\n   *\n   * @param url - The URL to fetch content from.\n   * @returns A promise that resolves to the fetched content as a string.\n   * @throws Will throw an error if the URL is invalid or if the fetch fails.\n   */\n  async fetchUrlContent(url) {\n    const urlRegex = /^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i;\n    const trimmedUrl = url.trim();\n    if (!urlRegex.test(trimmedUrl)) {\n      throw new Error('Invalid URL');\n    }\n    try {\n      // Use a regular expression to remove hidden characters\n      const cleanedUrl = trimmedUrl.replace(/[^\\x20-\\x7E]/g, '');\n      const requestURL = `https://r.jina.ai/${cleanedUrl.trim()}`;\n      const response = await fetch(requestURL.trim(), {\n        headers: {\n          'X-With-Generated-Alt': 'true'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const content = await response.text();\n      // Updated error matching\n      if (content.includes('Warning: Target URL returned error')) {\n        throw new Error(`Target URL (${trimmedUrl}) returned an error`);\n      }\n      if (content.trim().length === 0) {\n        throw new Error('Empty content received');\n      }\n      return content.replace(/\\(https?:\\/\\/[^\\s]+\\)/g, '').replace(/^\\s*$/gm, '').trim();\n    }\n    catch (error) {\n      console.error(`Failed to fetch content: ${url}`, error);\n      return '';\n    }\n  }\n  /**\n   * Counts the number of tokens in the provided content string.\n   *\n   * @param content - The content string to count tokens in.\n   * @returns The number of tokens in the content.\n   */\n  countTokens(content) {\n    if (!content || typeof content !== 'string') {\n      return 0;\n    }\n    // Normalize the content by trimming and reducing multiple whitespaces.\n    const normalizedContent = content\n      .trim()\n      .replace(/\\s+/g, ' ');\n    // Approximate tokens by breaking words, contractions, and common punctuation marks.\n    const tokens = normalizedContent.match(/\\b\\w+('\\w+)?\\b|[.,!?;:\"(){}[\\]]/g) || [];\n    // Heuristic: Long words (over 10 characters) are likely to be split into multiple tokens.\n    // GPT often breaks down long words into smaller subword chunks.\n    let approxTokenCount = 0;\n    tokens.forEach(token => {\n      // Break long words into chunks to approximate GPT subword tokenization.\n      if (token.length > 10) {\n        approxTokenCount += Math.ceil(token.length / 4); // Approximation: 4 characters per token.\n      }\n      else {\n        approxTokenCount += 1;\n      }\n    });\n    return approxTokenCount;\n  }\n  /**\n   * Trims the LLM content by tokens while ensuring that sentences or other structures (e.g., bullet points, paragraphs)\n   * are not clipped mid-way.\n   *\n   * @param content - The LLM-generated content string to trim.\n   * @param maxTokens - The maximum number of tokens allowed.\n   * @returns The trimmed content string.\n   */\n  trimLLMContentByTokens(content, maxTokens) {\n    const elements = content.split('\\n');\n    let accumulatedTokens = 0;\n    let trimmedContent = '';\n    for (const element of elements) {\n      const elementTokenCount = this.countTokens(element);\n      if (accumulatedTokens + elementTokenCount > maxTokens) {\n        break; // Stop if adding this element would exceed the token limit.\n      }\n      accumulatedTokens += elementTokenCount;\n      trimmedContent += element + '\\n'; // Add the whole structural element.\n    }\n    return trimmedContent;\n  }\n  /**\n   * Retrieves the allowed HTML tags based on the CKEditor schema.\n   *\n   * @returns An array of allowed HTML tags.\n   */\n  getAllowedHtmlTags() {\n    const editor = this.editor;\n    const schema = editor.model.schema;\n    const definitions = schema.getDefinitions();\n    const schemaNodes = Object.keys(definitions).sort();\n    // Map of CKEditor nodes to HTML tags\n    const nodeToHtmlMap = {\n      blockQuote: 'blockquote',\n      caption: 'figcaption',\n      codeBlock: 'pre',\n      heading1: 'h1',\n      heading2: 'h2',\n      heading3: 'h3',\n      imageBlock: 'img',\n      imageInline: 'img',\n      paragraph: 'p',\n      table: 'table',\n      tableCell: 'td',\n      tableRow: 'tr',\n      $listItem: 'li',\n      horizontalLine: 'hr'\n    };\n    // Map text attributes to HTML tags\n    const textAttributeToHtmlMap = {\n      bold: 'strong',\n      italic: 'em',\n      code: 'code',\n      strikethrough: 's',\n      subscript: 'sub',\n      superscript: 'sup',\n      underline: 'u',\n      linkHref: 'a'\n    };\n    // Collect allowed tags\n    const allowedTags = new Set();\n    // Add tags from node mappings\n    schemaNodes.forEach(node => {\n      if (node in nodeToHtmlMap) {\n        allowedTags.add(nodeToHtmlMap[node]);\n      }\n    });\n    // Add tags from text attributes\n    const textDefinition = definitions.$text;\n    if (textDefinition && textDefinition.allowAttributes) {\n      textDefinition.allowAttributes.forEach((attr) => {\n        if (attr in textAttributeToHtmlMap) {\n          allowedTags.add(textAttributeToHtmlMap[attr]);\n        }\n      });\n    }\n    // If listItem is present, add ul and ol\n    if (allowedTags.has('li')) {\n      allowedTags.add('ul');\n      allowedTags.add('ol');\n    }\n    // Sort and return the unique allowed tags\n    return Array.from(allowedTags).sort();\n  }\n  /**\n   * Extracts a portion of content based on the specified context size and direction.\n   *\n   * @param contentAfterPrompt - The content string to extract from.\n   * @param contextSize - The maximum size of the context to extract.\n   * @param reverse - A boolean indicating whether to extract in reverse order (default is false).\n   * @returns The extracted content string.\n   */\n  extractEditorContent(contentAfterPrompt, contextSize, reverse = false) {\n    let trimmedContent = '';\n    let charCount = 0;\n    // Tokenize the content into sentences using the sbd library\n    const sentences = sbd__WEBPACK_IMPORTED_MODULE_0__.sentences(contentAfterPrompt, {\n      preserve_whitespace: true,\n      html_boundaries: true,\n      allowed_tags: ['blockquote', 'figcaption', 'pre', 'h2', 'h1', 'h3', 'img', 'p', 'table', 'td', 'tr', 'li', 'hr', 'br']\n    });\n    // Iterate over the sentences based on the direction\n    const iterator = reverse ? sentences.reverse() : sentences;\n    for (const sentence of iterator) {\n      const sentenceLength = sentence.length;\n      // Check if adding this sentence would exceed the context size\n      if ((charCount + sentenceLength) / 4 <= contextSize) {\n        trimmedContent = reverse ?\n          sentence + trimmedContent :\n          trimmedContent + sentence;\n        charCount += sentenceLength;\n      }\n      else {\n        break; // Stop if adding the next sentence would exceed the context size\n      }\n    }\n    // Trim to remove any trailing whitespace and return the final trimmed content\n    return trimmedContent.trim();\n  }\n}\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./js/ckeditor5_plugins/aiassist/src/util/prompt.js?")},"./icons/ai-assist.svg":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\n  <path d=\\"M4.00815 5.01816H19.3851V10.9145H21.1594V3.2439H2.23389V22.1694H12.3955V20.3951H4.00815V5.01816Z\\" fill=\\"#222330\\"/>\\n  <path d=\\"M15.1908 20.046L20.9028 12.7065L22.9998 14.3385L17.2878 21.678L15.0341 22.755C14.8582 22.8391 14.6619 22.6862 14.7002 22.4951L15.1908 20.046Z\\" fill=\\"#222330\\"/>\\n  <path d=\\"M16.1211 8.43794V15.7494H14.5753V8.43794H16.1211Z\\" fill=\\"#222330\\"/>\\n  <path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M8.31458 15.7495H6.65807L9.18211 8.43804H11.1742L13.6947 15.7495H12.0382L11.4968 14.0823H8.85696L8.31458 15.7495ZM10.2067 10.1088L11.1051 12.8756H9.24951L10.1496 10.1088H10.2067Z\\" fill=\\"#222330\\"/>\\n</svg>\\n");\n\n//# sourceURL=webpack://CKEditor5.aiassist/./icons/ai-assist.svg?')},"./node_modules/sbd/lib/Match.js":(__unused_webpack_module,exports)=>{eval('var abbreviations;\r\n\r\nvar englishAbbreviations = [\r\n    "al",\r\n    "adj",\r\n    "assn",\r\n    "Ave",\r\n    "BSc", "MSc",\r\n    "Cell",\r\n    "Ch",\r\n    "Co",\r\n    "cc",\r\n    "Corp",\r\n    "Dem",\r\n    "Dept",\r\n    "ed",\r\n    "eg",\r\n    "Eq",\r\n    "Eqs",\r\n    "est",\r\n    "est",\r\n    "etc",\r\n    "Ex",\r\n    "ext", // + number?\r\n    "Fig",\r\n    "fig",\r\n    "Figs",\r\n    "figs",\r\n    "i.e",\r\n    "ie",\r\n    "Inc",\r\n    "inc",\r\n    "Jan","Feb","Mar","Apr","Jun","Jul","Aug","Sep","Sept","Oct","Nov","Dec",\r\n    "jr",\r\n    "mi",\r\n    "Miss", "Mrs", "Mr", "Ms",\r\n    "Mol",\r\n    "mt",\r\n    "mts",\r\n    "no",\r\n    "Nos",\r\n    "PhD", "MD", "BA", "MA", "MM",\r\n    "pl",\r\n    "pop",\r\n    "pp",\r\n    "Prof", "Dr",\r\n    "pt",\r\n    "Ref",\r\n    "Refs",\r\n    "Rep",\r\n    "repr",\r\n    "rev",\r\n    "Sec",\r\n    "Secs",\r\n    "Sgt", "Col", "Gen", "Rep", "Sen",\'Gov\', "Lt", "Maj", "Capt","St",\r\n    "Sr", "sr", "Jr", "jr", "Rev",\r\n    "Sun","Mon","Tu","Tue","Tues","Wed","Th","Thu","Thur","Thurs","Fri","Sat",\r\n    "trans",\r\n    "Univ",\r\n    "Viz",\r\n    "Vol",\r\n    "vs",\r\n    "v",\r\n];\r\n\r\nexports.setAbbreviations = function(abbr) {\r\n    if (abbr) {\r\n        abbreviations = abbr;\r\n    } else {\r\n        abbreviations = englishAbbreviations;\r\n    }\r\n}\r\n\r\nvar isCapitalized = exports.isCapitalized = function(str) {\r\n    return /^[A-Z][a-z].*/.test(str) || isNumber(str);\r\n}\r\n\r\n// Start with opening quotes or capitalized letter\r\nexports.isSentenceStarter = function(str) {\r\n    return isCapitalized(str) || /``|"|\'/.test(str.substring(0,2));\r\n}\r\n\r\nexports.isCommonAbbreviation = function(str) {\r\n    var noSymbols = str.replace(/[-\'`~!@#$%^&*()_|+=?;:\'",.<>\\{\\}\\[\\]\\\\\\/]/gi, "");\r\n\r\n    return ~abbreviations.indexOf(noSymbols);\r\n}\r\n\r\n// This is going towards too much rule based\r\nexports.isTimeAbbreviation = function(word, next) {\r\n    if (word === "a.m." || word === "p.m.") {\r\n        var tmp = next.replace(/\\W+/g, \'\').slice(-3).toLowerCase();\r\n\r\n        if (tmp === "day") {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexports.isDottedAbbreviation = function(word) {\r\n    var matches = word.replace(/[\\(\\)\\[\\]\\{\\}]/g, \'\').match(/(.\\.)*/);\r\n    return matches && matches[0].length > 0;\r\n}\r\n\r\n// TODO look for next words, if multiple are capitalized,\r\n// then it\'s probably not a sentence ending\r\nexports.isCustomAbbreviation = function(str) {\r\n    if (str.length <= 3) {\r\n        return true;\r\n    }\r\n\r\n    return isCapitalized(str);\r\n}\r\n\r\n// Uses current word count in sentence and next few words to check if it is\r\n// more likely an abbreviation + name or new sentence.\r\nexports.isNameAbbreviation = function(wordCount, words) {\r\n    if (words.length > 0) {\r\n        if (wordCount < 5 && words[0].length < 6 && isCapitalized(words[0])) {\r\n            return true;\r\n        }\r\n\r\n        var capitalized = words.filter(function(str) {\r\n            return /[A-Z]/.test(str.charAt(0));\r\n        });\r\n\r\n        return capitalized.length >= 3;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvar isNumber = exports.isNumber = function(str, dotPos) {\r\n    if (dotPos) {\r\n        str = str.slice(dotPos-1, dotPos+2);\r\n    }\r\n\r\n    return !isNaN(str);\r\n};\r\n\r\n// Phone number matching\r\n// http://stackoverflow.com/a/123666/951517\r\nexports.isPhoneNr = function(str) {\r\n    return str.match(/^(?:(?:\\+?1\\s*(?:[.-]\\s*)?)?(?:\\(\\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\\s*\\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\\s*(?:[.-]\\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\\s*(?:[.-]\\s*)?([0-9]{4})(?:\\s*(?:#|x\\.?|ext\\.?|extension)\\s*(\\d+))?$/);\r\n};\r\n\r\n// Match urls / emails\r\n// http://stackoverflow.com/a/3809435/951517\r\nexports.isURL = function(str) {\r\n    return str.match(/[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/);\r\n};\r\n\r\n// Starting a new sentence if beginning with capital letter\r\n// Exception: The word is enclosed in brackets\r\nexports.isConcatenated = function(word) {\r\n    var i = 0;\r\n\r\n    if ((i = word.indexOf(".")) > -1 ||\r\n        (i = word.indexOf("!")) > -1 ||\r\n        (i = word.indexOf("?")) > -1)\r\n    {\r\n        var c = word.charAt(i + 1);\r\n\r\n        // Check if the next word starts with a letter\r\n        if (c.match(/[a-zA-Z].*/)) {\r\n            return [word.slice(0, i), word.slice(i+1)];\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nexports.isBoundaryChar = function(word) {\r\n    return word === "." ||\r\n           word === "!" ||\r\n           word === "?";\r\n};\r\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./node_modules/sbd/lib/Match.js?')},"./node_modules/sbd/lib/sanitize-html-browser.js":module=>{eval("\r\nmodule.exports = function sanitizeHtml(text, opts) {\r\n  // Strip HTML from Text using browser HTML parser\r\n  if ((typeof text == 'string' || text instanceof String) && typeof document !== \"undefined\") {\r\n    var $div = document.createElement(\"DIV\");\r\n    $div.innerHTML = text;\r\n    text = ($div.textContent || '').trim();\r\n  }\r\n  //DOM Object\r\n  else if (typeof text === 'object' && text.textContent) {\r\n    text = (text.textContent || '').trim();\r\n  }\r\n\r\n  return text;\r\n};\r\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./node_modules/sbd/lib/sanitize-html-browser.js?")},"./node_modules/sbd/lib/stringHelper.js":(__unused_webpack_module,exports)=>{eval("\r\nexports.endsWithChar = function ends_with_char(word, c) {\r\n    if (c.length > 1) {\r\n        return c.indexOf(word.slice(-1)) > -1;\r\n    }\r\n\r\n    return word.slice(-1) === c;\r\n};\r\n\r\nexports.endsWith = function ends_with(word, end) {\r\n    return word.slice(word.length - end.length) === end;\r\n};\n\n//# sourceURL=webpack://CKEditor5.aiassist/./node_modules/sbd/lib/stringHelper.js?")},"./node_modules/sbd/lib/tokenizer.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('/*jshint node:true, laxcomma:true */\r\n\r\nvar sanitizeHtml = __webpack_require__(/*! sanitize-html */ "./node_modules/sbd/lib/sanitize-html-browser.js");\r\n\r\nvar stringHelper = __webpack_require__(/*! ./stringHelper */ "./node_modules/sbd/lib/stringHelper.js");\r\nvar Match  = __webpack_require__(/*! ./Match */ "./node_modules/sbd/lib/Match.js");\r\n\r\nvar newline_placeholder = " @~@ ";\r\nvar newline_placeholder_t = newline_placeholder.trim();\r\n\r\n\r\nvar whiteSpaceCheck = new RegExp("\\\\S", "");\r\nvar addNewLineBoundaries = new RegExp("\\\\n+|[-#=_+*]{4,}", "g");\r\nvar splitIntoWords = new RegExp("\\\\S+|\\\\n", "g");\r\n\r\n\r\n// Split the entry into sentences.\r\nexports.sentences = function(text, user_options) {\r\n    if (!text || typeof text !== "string" || !text.length) {\r\n        return [];\r\n    }\r\n\r\n    if (!whiteSpaceCheck.test(text)) {\r\n      // whitespace-only string has no sentences\r\n      return [];\r\n    }\r\n\r\n    var options = {\r\n        "newline_boundaries"  : false,\r\n        "html_boundaries"     : false,\r\n        "html_boundaries_tags": ["p","div","ul","ol"],\r\n        "sanitize"            : false,\r\n        "allowed_tags"        : false,\r\n        "preserve_whitespace" : false,\r\n        "abbreviations"       : null\r\n    };\r\n\r\n    if (typeof user_options === "boolean") {\r\n        // Deprecated quick option\r\n        options.newline_boundaries = true;\r\n    }\r\n    else {\r\n        // Extend options\r\n        for (var k in user_options) {\r\n            options[k] = user_options[k];\r\n        }\r\n    }\r\n\r\n    Match.setAbbreviations(options.abbreviations);\r\n\r\n    if (options.newline_boundaries) {\r\n        text = text.replace(addNewLineBoundaries, newline_placeholder);\r\n    }\r\n\r\n    if (options.html_boundaries) {\r\n        var html_boundaries_regexp = "(<br\\\\s*\\\\/?>|<\\\\/(" + options.html_boundaries_tags.join("|") + ")>)";\r\n        var re = new RegExp(html_boundaries_regexp, "g");\r\n        text = text.replace(re, "$1" + newline_placeholder);\r\n    }\r\n\r\n    if (options.sanitize || options.allowed_tags) {\r\n        if (! options.allowed_tags) {\r\n            options.allowed_tags = [""];\r\n        }\r\n\r\n        text = sanitizeHtml(text, { "allowedTags" : options.allowed_tags });\r\n    }\r\n\r\n\r\n    // Split the text into words\r\n    var words;\r\n    var tokens;\r\n\r\n    // Split the text into words\r\n    if (options.preserve_whitespace) {\r\n        // <br> tags are the odd man out, as whitespace is allowed inside the tag\r\n        tokens = text.split(/(<br\\s*\\/?>|\\S+|\\n+)/);\r\n\r\n        // every other token is a word\r\n        words = tokens.filter(function (token, ii) {\r\n          return ii % 2;\r\n        });\r\n    }\r\n    else {\r\n        // - see http://blog.tompawlak.org/split-string-into-tokens-javascript\r\n        words = text.trim().match(splitIntoWords);\r\n    }\r\n\r\n\r\n    var wordCount = 0;\r\n    var index = 0;\r\n    var temp  = [];\r\n    var sentences = [];\r\n    var current   = [];\r\n\r\n    // If given text is only whitespace (or nothing of \\S+)\r\n    if (!words || !words.length) {\r\n        return [];\r\n    }\r\n\r\n    for (var i=0, L=words.length; i < L; i++) {\r\n        wordCount++;\r\n\r\n        // Add the word to current sentence\r\n        current.push(words[i]);\r\n\r\n        // Sub-sentences, reset counter\r\n        if (~words[i].indexOf(",")) {\r\n            wordCount = 0;\r\n        }\r\n\r\n        if (Match.isBoundaryChar(words[i]) || stringHelper.endsWithChar(words[i], "?!") || words[i] === newline_placeholder_t) {\r\n            if ((options.newline_boundaries || options.html_boundaries) && words[i] === newline_placeholder_t) {\r\n                current.pop();\r\n            }\r\n\r\n            sentences.push(current);\r\n\r\n            wordCount = 0;\r\n            current   = [];\r\n\r\n            continue;\r\n        }\r\n\r\n\r\n        if (stringHelper.endsWithChar(words[i], "\\"") || stringHelper.endsWithChar(words[i], "")) {\r\n            words[i] = words[i].slice(0, -1);\r\n        }\r\n\r\n        // A dot might indicate the end sentences\r\n        // Exception: The next sentence starts with a word (non abbreviation)\r\n        //            that has a capital letter.\r\n        if (stringHelper.endsWithChar(words[i], ".")) {\r\n            // Check if there is a next word\r\n            // This probably needs to be improved with machine learning\r\n            if (i+1 < L) {\r\n                // Single character abbr.\r\n                if (words[i].length === 2 && isNaN(words[i].charAt(0))) {\r\n                    continue;\r\n                }\r\n\r\n                // Common abbr. that often do not end sentences\r\n                if (Match.isCommonAbbreviation(words[i])) {\r\n                    continue;\r\n                }\r\n\r\n                // Next word starts with capital word, but current sentence is\r\n                // quite short\r\n                if (Match.isSentenceStarter(words[i+1])) {\r\n                    if (Match.isTimeAbbreviation(words[i], words[i+1])) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Dealing with names at the start of sentences\r\n                    if (Match.isNameAbbreviation(wordCount, words.slice(i, 6))) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (Match.isNumber(words[i+1])) {\r\n                        if (Match.isCustomAbbreviation(words[i])) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Skip ellipsis\r\n                    if (stringHelper.endsWith(words[i], "..")) {\r\n                        continue;\r\n                    }\r\n\r\n                    //// Skip abbreviations\r\n                    // Short words + dot or a dot after each letter\r\n                    if (Match.isDottedAbbreviation(words[i])) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (Match.isNameAbbreviation(wordCount, words.slice(i, 5))) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            sentences.push(current);\r\n            current   = [];\r\n            wordCount = 0;\r\n\r\n            continue;\r\n        }\r\n\r\n        // Check if the word has a dot in it\r\n        if ((index = words[i].indexOf(".")) > -1) {\r\n            if (Match.isNumber(words[i], index)) {\r\n                continue;\r\n            }\r\n\r\n            // Custom dotted abbreviations (like K.L.M or I.C.T)\r\n            if (Match.isDottedAbbreviation(words[i])) {\r\n                continue;\r\n            }\r\n\r\n            // Skip urls / emails and the like\r\n            if (Match.isURL(words[i]) || Match.isPhoneNr(words[i])) {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (temp = Match.isConcatenated(words[i])) {\r\n            current.pop();\r\n            current.push(temp[0]);\r\n            sentences.push(current);\r\n\r\n            current = [];\r\n            wordCount = 0;\r\n            current.push(temp[1]);\r\n        }\r\n    }\r\n\r\n    if (current.length) {\r\n        sentences.push(current);\r\n    }\r\n\r\n\r\n    // Clear "empty" sentences\r\n    sentences = sentences.filter(function(s) {\r\n        return s.length > 0;\r\n    });\r\n\r\n    var result = sentences.slice(1).reduce(function (out, sentence) {\r\n      var lastSentence = out[out.length - 1];\r\n\r\n      // Single words, could be "enumeration lists"\r\n      if (lastSentence.length === 1 && /^.{1,2}[.]$/.test(lastSentence[0])) {\r\n          // Check if there is a next sentence\r\n          // It should not be another list item\r\n          if (!/[.]/.test(sentence[0])) {\r\n              out.pop()\r\n              out.push(lastSentence.concat(sentence));\r\n              return out;\r\n          }\r\n      }\r\n\r\n      out.push(sentence);\r\n\r\n      return out;\r\n    }, [ sentences[0] ]);\r\n\r\n    // join tokens back together\r\n    return result.map(function (sentence, ii) {\r\n      if (options.preserve_whitespace && !options.newline_boundaries && !options.html_boundaries) {\r\n        // tokens looks like so: [leading-space token, non-space token, space\r\n        // token, non-space token, space token... ]. In other words, the first\r\n        // item is the leading space (or the empty string), and the rest of\r\n        // the tokens are [non-space, space] token pairs.\r\n        var tokenCount = sentence.length * 2;\r\n\r\n        if (ii === 0) {\r\n          tokenCount += 1;\r\n        }\r\n\r\n        return tokens.splice(0, tokenCount).join("");\r\n      }\r\n\r\n      return sentence.join(" ");\r\n    });\r\n};\r\n\n\n//# sourceURL=webpack://CKEditor5.aiassist/./node_modules/sbd/lib/tokenizer.js?')},"ckeditor5/src/core.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('module.exports = (__webpack_require__(/*! dll-reference CKEditor5.dll */ "dll-reference CKEditor5.dll"))("./src/core.js");\n\n//# sourceURL=webpack://CKEditor5.aiassist/delegated_./core.js_from_dll-reference_CKEditor5.dll?')},"ckeditor5/src/ui.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('module.exports = (__webpack_require__(/*! dll-reference CKEditor5.dll */ "dll-reference CKEditor5.dll"))("./src/ui.js");\n\n//# sourceURL=webpack://CKEditor5.aiassist/delegated_./ui.js_from_dll-reference_CKEditor5.dll?')},"dll-reference CKEditor5.dll":e=>{"use strict";e.exports=CKEditor5.dll}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./js/ckeditor5_plugins/aiassist/src/index.js");return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()));